-- DECLARE
--  @REX_RECEIPT_PREFIX VARCHAR(20) = 'REX Order Number:'
-- , @REX_RECEIPT_PATTERN VARCHAR(100) = '%[0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]%'
-- , @REX_RECEIPT_NOTE_PATTERN VARCHAR(100)
-- , @D1 DATE = /*<START_DATE>*/'2017/07/01'/*</START_DATE>*/
-- , @D2 DATE = /*<END_DATE>*/'2018/06/30'/*</END_DATE>*/
-- ;
-- SET @REX_RECEIPT_NOTE_PATTERN = '%' + @REX_RECEIPT_PREFIX + ' ' + @REX_RECEIPT_PATTERN + '%'
-- ;
-- When Uncomment the above, making sure replace the query part with the variables and uncomment OPTION(RECOMPILE) to speed up the query
-- Here I choose static query that prove to be run fastest (considering the speed of replacing variable tags in program )
WITH
cte_payments as (
  SELECT
    B1.SERIALNUMBER, B2.DATEOFPAYMENT, B1.PAYMENTAMOUNT
    , S1.SOURCETYPE
    , C1.CONTACTTYPE, C1.PRIMARYCATEGORY, C1.DONOTMAIL, C1.DONOTMAILREASON
    , C1.SORTKEYREF1, C1.SORTKEYREFREL1 , C1.SORTKEYREFREL2
    , C2.DONOTCALL
    , [MANUALRECEIPTNO] = LTRIM(RTRIM(ISNULL(B2.MANUALRECEIPTNO, '')))
  FROM
    TBL_BATCHITEMSPLIT        B1
    LEFT JOIN TBL_BATCHITEM   B2 ON (B1.SERIALNUMBER = B2.SERIALNUMBER) AND (B1.RECEIPTNO = B2.RECEIPTNO) AND (B1.ADMITNAME = B2.ADMITNAME)
    LEFT JOIN TBL_BATCHHEADER B4 ON (B2.ADMITNAME = B4.ADMITNAME)
    LEFT JOIN TBL_SOURCECODE  S1 ON (B1.SOURCECODE = S1.SOURCECODE)
    LEFT JOIN TBL_CONTACT     C1 ON (B1.SERIALNUMBER = C1.SERIALNUMBER)
    LEFT JOIN TBL_CONTACTATTRIBUTE C2 ON (B1.SERIALNUMBER = C2.SERIALNUMBER)
  WHERE
    (B2.REVERSED IS NULL OR NOT (B2.REVERSED=1 OR B2.REVERSED=-1)) -- Full reversal and re-entry should be excluded all time
    AND (B4.STAGE ='Batch Approved')
    AND (C1.CONTACTTYPE NOT LIKE 'ADDRESS')
    AND B2.DATEOFPAYMENT BETWEEN /*<START_DATE>*/'2017/07/01'/*</START_DATE>*/ AND /*<END_DATE>*/'2018/06/30'/*</END_DATE>*/
)
-- --------------------------------------------------------------
,cte_first_date as (
  SELECT SERIALNUMBER, MIN(DATEOFPAYMENT) AS [FIRSTDATE]
  FROM TBL_BATCHITEM
  WHERE (REVERSED IS NULL OR NOT (REVERSED=1 OR REVERSED=-1 OR REVERSED=2))
  GROUP BY SERIALNUMBER
)
  -- --------------------------------------------------------------
,cte_rex_orders as (
  SELECT SERIALNUMBER, DATEOFPAYMENT,
    CASE WHEN NOT MANUALRECEIPTNO LIKE '%[0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]%'
    THEN
      SUBSTRING(NOTES
        ,PATINDEX('%REX Order Number: [0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]%', NOTES) + LEN('REX Order Number:') + 1
        ,11)
    ELSE LTRIM(RTRIM(ISNULL(MANUALRECEIPTNO, '')))
    END AS [ORDERID]
  FROM TBL_BATCHITEM
  WHERE
    (REVERSED IS NULL OR NOT (REVERSED=1 OR REVERSED=-1 OR REVERSED=2))
    AND (MANUALRECEIPTNO LIKE '%[0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]%' OR NOTES LIKE '%REX Order Number: [0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]%')
    AND DATEOFPAYMENT between /*<START_DATE>*/'2017/07/01'/*</START_DATE>*/ AND /*<END_DATE>*/'2018/06/30'/*</END_DATE>*/
  GROUP BY SERIALNUMBER, DATEOFPAYMENT, MANUALRECEIPTNO, NOTES
)
-- --------------------------------------------------------------
,cte_onboard_last as (
   -- The reason of not using aggregating function is all values from the same record are needed not individual aggreation
  SELECT * FROM
  (
    SELECT *, ROW_NUMBER() OVER(PARTITION BY SERIALNUMBER ORDER BY CREATED DESC) AS [ROW]
    FROM Tbl_CONTACTPARAMETER
    WHERE PARAMETERNAME = 'Merch Onboarding'
  ) tmp
  WHERE ROW =1
)
-- --------------------------------------------------------------
select
  t1.SERIALNUMBER, t1.FIRSTDATE
  ,[FIRSTORDER]= MIN(t2.ORDERID)
  ,[FIRSTORDERS] = COUNT(DISTINCT t2.ORDERID)
  ,[FIRSTDATETOTAL]=SUM(t3.PAYMENTAMOUNT)
  ,[MERCHANDISE_TOTAL] = SUM(CASE WHEN t3.SOURCETYPE like 'Merch%' THEN t3.PAYMENTAMOUNT ELSE 0 END)
  ,[MERCHANDISE_PURCHASE] = SUM(CASE WHEN t3.SOURCETYPE like 'Merch%Purchase' or t3.SOURCETYPE like 'Merch%Postage' THEN t3.PAYMENTAMOUNT ELSE 0 END)
  ,[MERCHANDISE_PLEDGE] = SUM(CASE WHEN t3.SOURCETYPE like 'Merch%Sponsorship'THEN  t3.PAYMENTAMOUNT ELSE 0 END)
  ,[MERCHANDISE_DONATION] = SUM(CASE WHEN t3.SOURCETYPE like 'Merch%Donation'THEN  t3.PAYMENTAMOUNT ELSE 0 END)
  ,[MERCHANDISE_GOL] = SUM(CASE WHEN t3.SOURCETYPE like 'Merch%Gift%of%love'THEN  t3.PAYMENTAMOUNT ELSE 0 END)
  ,t3.CONTACTTYPE, t3.PRIMARYCATEGORY, t3.DONOTMAIL, t3.DONOTMAILREASON, t3.DONOTCALL, t3.SORTKEYREF1, t3.SORTKEYREFREL1, t3.SORTKEYREFREL2
  ,[PARAMETERNAME]=MIN(t4.PARAMETERNAME)
  ,[PARAMETERVALUE]=MIN(t4.PARAMETERVALUE)
  ,[EFFECTIVEFROM]=MIN(t4.EFFECTIVEFROM)
  ,[EFFECTIVETO]=MIN(t4.EFFECTIVETO)
  ,[PARAMETERNOTE]=MIN(t4.PARAMETERNOTE)
  ,[FIRST_ORDER_SOURCE] = IIF(MIN(t3.MANUALRECEIPTNO)=MIN(t2.ORDERID),'Alternative Receipt Number','Notes' )
  ,CASE WHEN MIN(t4.PARAMETERNAME) IS NULL
  THEN 0
  ELSE
    -1
  END
from
  cte_first_date t1
  left join cte_rex_orders t2 on (t1.FIRSTDATE = t2.DATEOFPAYMENT and t1.SERIALNUMBER = t2.SERIALNUMBER)
  left join cte_payments t3 on (t1.FIRSTDATE = t3.DATEOFPAYMENT and t1.SERIALNUMBER = t3.SERIALNUMBER)
  left join cte_onboard_last t4 on (t1.SERIALNUMBER = t4.SERIALNUMBER)
where
  t1.FIRSTDATE between /*<START_DATE>*/'2017/07/01'/*</START_DATE>*/ and /*<END_DATE>*/'2018/06/30'/*</END_DATE>*/
group by
  t1.SERIALNUMBER,t1.FIRSTDATE
  ,t3.CONTACTTYPE, t3.PRIMARYCATEGORY, t3.DONOTMAIL, t3.DONOTMAILREASON, t3.DONOTCALL, t3.SORTKEYREF1, t3.SORTKEYREFREL1 ,t3.SORTKEYREFREL2
having
  SUM(CASE WHEN t3.SOURCETYPE like 'Merch%' THEN t3.PAYMENTAMOUNT ELSE 0 END) > 0
order by
  t1.FIRSTDATE desc

-- ----------------------------------
-- OPTION(RECOMPILE)